"use strict";(self.webpackChunkqtrobot_documentation=self.webpackChunkqtrobot_documentation||[]).push([[3271],{92329:function(e,t,n){n.r(t),n.d(t,{frontMatter:function(){return p},contentTitle:function(){return c},metadata:function(){return h},assets:function(){return u},toc:function(){return d},default:function(){return k}});var a=n(87462),o=n(63366),r=(n(67294),n(3905)),s=n(55381),i=n(14702),l=["components"],p={id:"python_ros_sync_robot_behaviors",title:"Synchronizing QTrobot Behaviors",hide_table_of_contents:!0},c="Synchronizing QTrobot Behaviors",h={unversionedId:"tutorials/python/python_ros_sync_robot_behaviors",id:"tutorials/python/python_ros_sync_robot_behaviors",title:"Synchronizing QTrobot Behaviors",description:"signalcellularalt &nbsp;Level:&nbsp; Intermediate",source:"@site/docs/tutorials/python/python_ros_sync_robot_behaviors.md",sourceDirName:"tutorials/python",slug:"/tutorials/python/python_ros_sync_robot_behaviors",permalink:"/docs/tutorials/python/python_ros_sync_robot_behaviors",tags:[],version:"current",frontMatter:{id:"python_ros_sync_robot_behaviors",title:"Synchronizing QTrobot Behaviors",hide_table_of_contents:!0},sidebar:"code_tutorials_sidebar",previous:{title:"Human hands detection",permalink:"/docs/tutorials/python/python_ros_hands"},next:{title:"Using QTrobot microphone",permalink:"/docs/tutorials/python/python_ros_respeaker"}},u={},d=[{value:"Create a python project",id:"create-a-python-project",level:2},{value:"Synchronizer",id:"synchronizer",level:2},{value:"Main Code",id:"main-code",level:2},{value:"Explanation",id:"explanation",level:3}],m={toc:d};function k(e){var t=e.components,n=(0,o.Z)(e,l);return(0,r.kt)("wrapper",(0,a.Z)({},m,n,{components:t,mdxType:"MDXLayout"}),(0,r.kt)("h1",{id:"synchronizing-qtrobot-behaviors"},"Synchronizing QTrobot Behaviors"),(0,r.kt)("div",{className:"admonition admonition-info alert alert--info"},(0,r.kt)("div",{parentName:"div",className:"admonition-heading"},(0,r.kt)("h5",{parentName:"div"},(0,r.kt)("span",{parentName:"h5",className:"admonition-icon"},(0,r.kt)("svg",{parentName:"span",xmlns:"http://www.w3.org/2000/svg",width:"14",height:"16",viewBox:"0 0 14 16"},(0,r.kt)("path",{parentName:"svg",fillRule:"evenodd",d:"M7 2.3c3.14 0 5.7 2.56 5.7 5.7s-2.56 5.7-5.7 5.7A5.71 5.71 0 0 1 1.3 8c0-3.14 2.56-5.7 5.7-5.7zM7 1C3.14 1 0 4.14 0 8s3.14 7 7 7 7-3.14 7-7-3.14-7-7-7zm1 3H6v5h2V4zm0 6H6v2h2v-2z"}))),"Overview")),(0,r.kt)("div",{parentName:"div",className:"admonition-content"},(0,r.kt)(s.Z,{mdxType:"Icon"},"signal_cellular_alt")," ",(0,r.kt)(i.Z,{mdxType:"Markdown"},"\xa0**Level:**\xa0 *Intermediate*"),(0,r.kt)("br",null)," ",(0,r.kt)(s.Z,{mdxType:"Icon"}," track_changes ")," ",(0,r.kt)(i.Z,{mdxType:"Markdown"},"\xa0**Goal:**\xa0 *learn how to synchronize QTrobot behaviors/actions*"),(0,r.kt)("br",null)," ",(0,r.kt)(s.Z,{mdxType:"Icon"}," task_alt ")," ",(0,r.kt)(i.Z,{mdxType:"Markdown"},"\xa0**Requirements:**"),(0,r.kt)("ul",{parentName:"div"},(0,r.kt)("li",{parentName:"ul"},"\xa0","\xa0",(0,r.kt)("a",{parentName:"li",href:"/docs/intro_code"},"Quick start with coding on QTrobot")),(0,r.kt)("li",{parentName:"ul"},"\xa0","\xa0",(0,r.kt)("a",{parentName:"li",href:"/docs/tutorials/python/python_ros_project"},"Create a ROS python project")),(0,r.kt)("li",{parentName:"ul"},"\xa0","\xa0",(0,r.kt)("a",{parentName:"li",href:"/docs/tutorials/python/python_ros_publish"},"QTrobot interfaces using ROS Topics")),(0,r.kt)("li",{parentName:"ul"},"\xa0","\xa0",(0,r.kt)("a",{parentName:"li",href:"/docs/tutorials/python/python_ros_subscribe"},"QTrobot interfaces using ROS Subscribers"))))),(0,r.kt)("p",null,"In this tutorial we will learn how to synchronize QTrobot behaviors or actions. We want to make QTrobot talk and do a gesture at the same time and wait for both of them to finish.\nThere are multiple ways how to do it.\nOne option is to use ROS Topics which are non-blocking and we would be able to execute both rostopics at the same time."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-python"},'talk_pub.publish("Hello! my name is QT!") #rostopic\ngesture_play.publish("QT/happy") #rostopic\n')),(0,r.kt)("p",null,"This will make QTrobot say ",(0,r.kt)("strong",{parentName:"p"},'"Hello! my name is QT!"')," and play a ",(0,r.kt)("strong",{parentName:"p"},'"happy"')," gesture at the same time. The issue is that we don't know how long it takes to finish and we can't wait for both of them finish. That means whatever is after ",(0,r.kt)("strong",{parentName:"p"},'"gesture_play"')," in the code, it will be executed without waiting for gesture_play/talk_pub to finish. This might work in certain situations, but for our use case we need to find something else."),(0,r.kt)("p",null,"The other option would be to use mix of ROS topics and services, because ROS services are blocking and will stop/block the execution of the program until that service call finishes.\nIn the same example above we could replace gesture play topic with a ros service call and the code would look like this:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-python"},"talk_pub.publish(\"Hello! my name is QT!\") #rostopic\ngesturePlay('QT/happy', 0) #rosservice\n")),(0,r.kt)("p",null,"In this situation ",(0,r.kt)("strong",{parentName:"p"},"talk_pub")," and ",(0,r.kt)("strong",{parentName:"p"},"gesturePlay")," will execute at the same time, and the ",(0,r.kt)("strong",{parentName:"p"},"gesturePlay")," service call will block the execution of the program until it finishes playing the gesture. We come to an issue that, in this example, it doesn't matter how long or short the text is used for ",(0,r.kt)("strong",{parentName:"p"},"talk_pub"),", program will continue after the ",(0,r.kt)("strong",{parentName:"p"},'"gesturePlay"')," service is done. "),(0,r.kt)("p",null,"This doesn't solve our task, in which we need to wait for both to finish. So let's implement a synchronizer for our actions/behaviors, in which we will execute both gesturePlay and talkText at the same time and wait for both of them to finish."),(0,r.kt)("h2",{id:"create-a-python-project"},"Create a python project"),(0,r.kt)("p",null,"First we create a python project for our tutorial. let's call it ",(0,r.kt)("inlineCode",{parentName:"p"},"tutorial_sync_qt_behaviors")," and add the required python files: "),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},'cd ~/catkin_ws/src\ncatkin_create_pkg tutorial_sync_qt_behaviors std_msgs rospy roscpp -D "Synchronizing QTrobot Behaviors"\ncd tutorial_sync_qt_behaviors/src\ntouch tutorial_sync_qt_behaviors.py\ntouch synchronizer.py\nchmod +x tutorial_sync_qt_behaviors.py\n')),(0,r.kt)("h2",{id:"synchronizer"},"Synchronizer"),(0,r.kt)("p",null,"TaskSynchronizer is a simple class, using asyncio and threads, that enables us to run multiple tasks at the same time and wait for them to finish.\nOpen the ",(0,r.kt)("inlineCode",{parentName:"p"},"synchronizer.py")," file and add the following code:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-python"},'import time\nimport asyncio\nimport concurrent.futures\n\nclass TaskSynchronizer():\n    """\n    A simple concurrent tasks synchornizer\n    """\n\n    def __init__(self, max_workers=5):\n        self.loop = asyncio.get_event_loop()\n        self.executor = concurrent.futures.ThreadPoolExecutor(\n            max_workers=max_workers)\n\n    def __worker(self, *args):\n        delay_exe = args[0][0]\n        func = args[0][1]\n        time.sleep(delay_exe)\n        return func()\n\n    async def __non_blocking(self, tasks):\n        fs = []\n        for task in tasks:\n            fs.append(self.loop.run_in_executor(\n                self.executor, self.__worker, task))\n        done, pending = await asyncio.wait(fs=fs, return_when=asyncio.ALL_COMPLETED)\n        results = [task.result() for task in done]\n        return results\n\n    def sync(self, tasks):\n        """\n        call this function with multiple tasks to run concurrently.\n        tasks is a list of (delay, lamda function) tuple. for exmaple:\n        tasks = [ (0, lambda: print("hello")), (3, lambda: print("world")), ...]\n        returns a list of each lamda function return value\n        """\n        results = self.loop.run_until_complete(self.__non_blocking(tasks))\n        return results\n')),(0,r.kt)("h2",{id:"main-code"},"Main Code"),(0,r.kt)("p",null,"Open the ",(0,r.kt)("inlineCode",{parentName:"p"},"tutorial_sync_qt_behaviors.py")," file and add the following code and please check the ",(0,r.kt)("a",{parentName:"p",href:"/docs/tutorials/python/python_ros_sync_robot_behaviors#explanation"},"explanation")," below:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-python"},"#!/usr/bin/env python\nimport sys\nimport rospy\nfrom qt_robot_interface.srv import *\nfrom qt_gesture_controller.srv import *\nfrom synchronizer import TaskSynchronizer\n\nif __name__ == '__main__':\n    rospy.init_node('my_tutorial_node')\n    rospy.loginfo(\"my_tutorial_node started!\")\n\n   # define a ros service\n    talkText = rospy.ServiceProxy('/qt_robot/behavior/talkText', behavior_talk_text)\n    gesturePlay = rospy.ServiceProxy('/qt_robot/gesture/play', gesture_play)\n\n    # block/wait for ros service\n    rospy.wait_for_service('/qt_robot/behavior/talkText')\n    rospy.wait_for_service('/qt_robot/gesture/play')\n\n    # ceate an instance of TaskSynchronizer\n    ts = TaskSynchronizer()\n\n    # call talkText and gesturePlay at the same time\n    # wait until both finish their jobs\n    print('calling talkText and gesturePlay...')\n    results = ts.sync([\n        (0, lambda: talkText('Hello! my name is QT!')),\n        (0, lambda: gesturePlay('QT/happy', 0))\n    ])\n    print('talkText and gesturePlay finished.')\n")),(0,r.kt)("h3",{id:"explanation"},"Explanation"),(0,r.kt)("p",null,"ROS Services are defined by srv files, which contains a request message and a response message. First we import all from ",(0,r.kt)("inlineCode",{parentName:"p"},"qt_robot_interface.srv")," and ",(0,r.kt)("inlineCode",{parentName:"p"},"qt_gesture_controller.srv"),". This will import all srv files that are under ",(0,r.kt)("inlineCode",{parentName:"p"},"qt_robot_interface.srv")," and ",(0,r.kt)("inlineCode",{parentName:"p"},"qt_gesture_controller.srv"),".\nIn this example we want to call talkText and gesturePaly services at the same time, so we need ",(0,r.kt)("inlineCode",{parentName:"p"},"behavior_talk_text")," and ",(0,r.kt)("inlineCode",{parentName:"p"},"gesture_play"),"."),(0,r.kt)("div",{className:"admonition admonition-tip alert alert--success"},(0,r.kt)("div",{parentName:"div",className:"admonition-heading"},(0,r.kt)("h5",{parentName:"div"},(0,r.kt)("span",{parentName:"h5",className:"admonition-icon"},(0,r.kt)("svg",{parentName:"span",xmlns:"http://www.w3.org/2000/svg",width:"12",height:"16",viewBox:"0 0 12 16"},(0,r.kt)("path",{parentName:"svg",fillRule:"evenodd",d:"M6.5 0C3.48 0 1 2.19 1 5c0 .92.55 2.25 1 3 1.34 2.25 1.78 2.78 2 4v1h5v-1c.22-1.22.66-1.75 2-4 .45-.75 1-2.08 1-3 0-2.81-2.48-5-5.5-5zm3.64 7.48c-.25.44-.47.8-.67 1.11-.86 1.41-1.25 2.06-1.45 3.23-.02.05-.02.11-.02.17H5c0-.06 0-.13-.02-.17-.2-1.17-.59-1.83-1.45-3.23-.2-.31-.42-.67-.67-1.11C2.44 6.78 2 5.65 2 5c0-2.2 2.02-4 4.5-4 1.22 0 2.36.42 3.22 1.19C10.55 2.94 11 3.94 11 5c0 .66-.44 1.78-.86 2.48zM4 14h5c-.23 1.14-1.3 2-2.5 2s-2.27-.86-2.5-2z"}))),"Tip")),(0,r.kt)("div",{parentName:"div",className:"admonition-content"},(0,r.kt)("p",{parentName:"div"},"How do we know which service an interface uses? well, There is a useful command in ROS which tells you that: "),(0,r.kt)("pre",{parentName:"div"},(0,r.kt)("code",{parentName:"pre"},"Type: qt_robot_interface/behavior_talk_text\nArgs: message\n")))),(0,r.kt)("p",null,"Next we import ",(0,r.kt)("inlineCode",{parentName:"p"},"TaskSynchronizer")," class from ",(0,r.kt)("inlineCode",{parentName:"p"},"synchronizer"),". This will allow as to create an instance of TaskSynchronizer and execute class function calls.\nIn the main, after we define ros services that we need, we create an instance of ",(0,r.kt)("inlineCode",{parentName:"p"},"TaskSynchronizer"),":"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-python"},"# ceate an instance of TaskSynchronizer\nts = TaskSynchronizer()\n")),(0,r.kt)("p",null,"We want to use ",(0,r.kt)("inlineCode",{parentName:"p"},"sync")," function from ",(0,r.kt)("inlineCode",{parentName:"p"},"TaskSynchronizer"),", to which we can pass multiple tasks that we want to run concurrently.\nWe provide an array of ",(0,r.kt)("inlineCode",{parentName:"p"},"tasks")," to the function, which are tuples of delay and lambda function.\nTask should look something like this:\n",(0,r.kt)("inlineCode",{parentName:"p"},'(0, lambda: print("hello"))')),(0,r.kt)("p",null,"First parameter ",(0,r.kt)("strong",{parentName:"p"},"delay")," -> ",(0,r.kt)("strong",{parentName:"p"},"0"),", will tell synchronizer when to execute second parameter ",(0,r.kt)("strong",{parentName:"p"},"lambda function")," -> ",(0,r.kt)("strong",{parentName:"p"},'lambda: print("hello")'),"."),(0,r.kt)("p",null,"Array of task would look like this example:\n",(0,r.kt)("inlineCode",{parentName:"p"}," tasks = [ (0, lambda: Task1()), (0, lambda: Task2()), (0.6, lambda: Task3()), ...]")),(0,r.kt)("p",null,(0,r.kt)("a",{parentName:"p",href:"https://mermaid.live/edit#pako:eNpNjrtuwzAMRX9FINDNMCT5QUtz0albMxVaiFhJhVhyYNOAUyP_XjnJUE68h8QhNziOvQcLZ0rMLjnuif3HOEVise6Z1jC_8tunSyIXBx68OIToh5D8k7l0oPkilBWyEKqRMs4vpJ9I_kOVFa3MEHcGBUSf_aHPb2y7zQH_-Ogd2Nz2_kTLwA5cuudVWnj8uqUjWJ4WX8By3R9-D3SeKII90TBneqUEdoMVbIVlawy2dWdqVLIp4AZWKywRUaNstG7qTnX3An7HMQtk2Rk0XdWgUloaifph-34M95P3P0x1XKU"},(0,r.kt)("img",{parentName:"a",src:"https://mermaid.ink/img/pako:eNpNjrtuwzAMRX9FINDNMCT5QUtz0albMxVaiFhJhVhyYNOAUyP_XjnJUE68h8QhNziOvQcLZ0rMLjnuif3HOEVise6Z1jC_8tunSyIXBx68OIToh5D8k7l0oPkilBWyEKqRMs4vpJ9I_kOVFa3MEHcGBUSf_aHPb2y7zQH_-Ogd2Nz2_kTLwA5cuudVWnj8uqUjWJ4WX8By3R9-D3SeKII90TBneqUEdoMVbIVlawy2dWdqVLIp4AZWKywRUaNstG7qTnX3An7HMQtk2Rk0XdWgUloaifph-34M95P3P0x1XKU?type=png",alt:null}))),(0,r.kt)("p",null,"As you can see above in the graph, Task1 and Task2 start at the same time, because they don't have any delay set and Task3 will be executed with 600ms of delay.\nNow when we now how ",(0,r.kt)("inlineCode",{parentName:"p"},"sync")," function works, we can implement talkText and gesturePlay service calls like this:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-python"},"# call talkText and gesturePlay at the same time \n# wait until both finish their jobs\nresults = ts.sync([\n    (0, lambda: talkText('Hello! my name is QT!')),\n    (0, lambda: gesturePlay('QT/happy', 0))\n])\n")),(0,r.kt)("p",null,"If we wanted to execute gesturePlay a bit later then talkText, we could write something like this:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-python"},"# call gesturePlay 0.5s (500ms) after talkText \n# wait until both finish their jobs\nresults = ts.sync([\n    (0, lambda: talkText('Hello! my name is QT!')),\n    (0.5, lambda: gesturePlay('QT/happy', 0))\n])\n")),(0,r.kt)("p",null,"As explained above ",(0,r.kt)("inlineCode",{parentName:"p"},"sync")," function waits (blocking) until all services finish their jobs and after that returns, so if we wanted to have two/three sets of actions/behaviors that QTrobot should execute, it might look something like this:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-python"},"# calling first set\nresults = ts.sync([\n    (0, lambda: talkText('Hello! my name is QT!')),\n    (0, lambda: gesturePlay('QT/happy', 0))\n])\n# after first set executes it will call second set\nresults = ts.sync([\n    (0, lambda: talkText('It was nice meeting you!')),\n    (0, lambda: gesturePlay('QT/bye', 0))\n])\n")),(0,r.kt)("p",null,"In this example we just used ",(0,r.kt)("strong",{parentName:"p"},"gesturePlay")," and ",(0,r.kt)("strong",{parentName:"p"},"talkText"),", but you can use any other ros services which you want to synchronize."))}k.isMDXComponent=!0}}]);