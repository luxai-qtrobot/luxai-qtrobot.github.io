"use strict";(self.webpackChunkqtrobot_documentation=self.webpackChunkqtrobot_documentation||[]).push([[474],{6184:(e,s,t)=>{t.r(s),t.d(s,{assets:()=>l,contentTitle:()=>a,default:()=>p,frontMatter:()=>r,metadata:()=>c,toc:()=>h});var o=t(5893),i=t(1151),n=t(9656);const r={id:"intro_ros",title:"Intoduction to ROS",hide_table_of_contents:!0},a=void 0,c={id:"tutorials/intro_ros",title:"Intoduction to ROS",description:"signalcellularalt &nbsp;Level:&nbsp; Basic",source:"@site/docs/tutorials/ros_basics.mdx",sourceDirName:"tutorials",slug:"/tutorials/intro_ros",permalink:"/docs/tutorials/intro_ros",draft:!1,unlisted:!1,tags:[],version:"current",frontMatter:{id:"intro_ros",title:"Intoduction to ROS",hide_table_of_contents:!0},sidebar:"code_tutorials_sidebar",next:{title:"Create a ROS python project",permalink:"/docs/tutorials/python/python_ros_project"}},l={},h=[{value:"What is ROS?",id:"what-is-ros",level:2},{value:"Topics and Messages",id:"topics-and-messages",level:2},{value:"Publishers and Subscribers",id:"publishers-and-subscribers",level:2},{value:"Service calls",id:"service-calls",level:2},{value:"QTrobot ROS Topics and Services",id:"qtrobot-ros-topics-and-services",level:2},{value:"QTrobot speech interface",id:"qtrobot-speech-interface",level:2},{value:"QTrobot talk text interface",id:"qtrobot-talk-text-interface",level:2},{value:"QTrobot emotion interface",id:"qtrobot-emotion-interface",level:2},{value:"QTrobot gesture interface",id:"qtrobot-gesture-interface",level:2},{value:"QTrobot audio interface",id:"qtrobot-audio-interface",level:2}];function d(e){const s={a:"a",admonition:"admonition",code:"code",em:"em",h2:"h2",p:"p",pre:"pre",strong:"strong",...(0,i.a)(),...e.components};return(0,o.jsxs)(o.Fragment,{children:[(0,o.jsx)(s.admonition,{title:"Overview",type:"info",children:(0,o.jsxs)(s.p,{children:[(0,o.jsx)(n.Z,{children:"signal_cellular_alt"})," \xa0",(0,o.jsx)(s.strong,{children:"Level:"}),"\xa0 ",(0,o.jsx)(s.em,{children:"Basic"}),"\n",(0,o.jsx)("br",{})," ",(0,o.jsx)(n.Z,{children:" track_changes "})," \xa0",(0,o.jsx)(s.strong,{children:"Goal:"}),"\xa0 ",(0,o.jsx)(s.em,{children:"Understanding the general concept of ROS framework"})]})}),"\n",(0,o.jsx)(s.h2,{id:"what-is-ros",children:"What is ROS?"}),"\n",(0,o.jsxs)(s.p,{children:["If you ever had any chance to develop code for robot or taking part in a robotic team, you have definitely heard of ",(0,o.jsx)(s.a,{href:"https://www.ros.org",children:"ROS"}),". The Robot Operating System (ROS) is the most used and flexible framework for writing robot software. It is a collection of tools, libraries, and best practices to simplify the task of creating complex and robust robot application. In a nutshell, ROS uses distributed publish and subscribe architecture where different software components communicate with each other via messages. Distributed architecture means that your program which is running on a machine (e.g. your PC or a Tablet) can communicate with and commands a second program running on another machine (e.g. on the robot). Taking a deep dive into ROS software architecture is beyond the objective of this blog. Nevertheless I will explain its main concepts using simpler words and examples in the following sections."]}),"\n",(0,o.jsx)(s.h2,{id:"topics-and-messages",children:"Topics and Messages"}),"\n",(0,o.jsxs)(s.p,{children:["You may still recall online chatrooms from some late 90s chat programs. People, who were interested in specific ",(0,o.jsx)(s.strong,{children:"topic"})," used to show up in a relevant chat room and talk with each other by exchanging ",(0,o.jsx)(s.strong,{children:"messages"}),". ROS topics and messages work in a similar manner. A software program can show interest in a specific topic by subscribing to its channel or advertising a channel on a new topic. Via these channels, programs then can communicate by exchanging messages."]}),"\n",(0,o.jsx)("center",{children:(0,o.jsx)("img",{src:"/img/ros_pub_sub.png",width:"60%"})}),"\n",(0,o.jsxs)(s.p,{children:["To understand each other, people must speak the same language in a common chatroom. Likewise, ROS programs must also know the ",(0,o.jsx)(s.strong,{children:"type"})," of the message used in specific topic. For example, QTrobot advertises a topic called ",(0,o.jsx)(s.code,{children:"/qt_robot/speech/say"})," which uses message of type ",(0,o.jsx)(s.code,{children:"std_msgs/String"}),". It is very common and standard message type in ROS which represents simple String (text) message. Messages can have more complex type which composed of different simpler messages. For example, ",(0,o.jsx)(s.code,{children:"/qt_nuitrack_app/faces"})," topic uses a custom message of type ",(0,o.jsx)(s.code,{children:"qt_nuitrack_app/FaceInfo"}),". This message represents a collection of human facial features such as emotions (e.g. happy, angry, surprised), the person estimated age, eyes gazing angles, etc. You may want to take a look at the ",(0,o.jsx)(s.a,{href:"/docs/api_ros#list-of-available-interfaces",children:"List of available topics"})," which are advertised by QTrobot."]}),"\n",(0,o.jsx)(s.h2,{id:"publishers-and-subscribers",children:"Publishers and Subscribers"}),"\n",(0,o.jsxs)(s.p,{children:["Consider again our chatroom example. The person who is writing a message is the ",(0,o.jsx)(s.strong,{children:"publisher"})," and those who are reading the message are ",(0,o.jsx)(s.strong,{children:"subscribers"}),". One or multiple publishers can send (publish) messages on the same topic. Similarly multiple subscribers can receive messages from the same topic."]}),"\n",(0,o.jsx)(s.h2,{id:"service-calls",children:"Service calls"}),"\n",(0,o.jsxs)(s.p,{children:["The publish-subscribe model that we have explained is a very flexible communication paradigm. However, it is a on-way communication: one talks and the others listen. Indeed, it is possible to establish two way communication by letting each entity becomes publisher and subscriber at the same time, but as you can imagine this may get  chaotic (especially when everyone wants to talk simultaneously) and become tedious to be synchronized with each other. We need something like request-response model: one requests something from an entity and wait until the other replies.\nLet's consider pizza ordering scenario: there is a restaurant which provides pizza delivery ",(0,o.jsx)(s.strong,{children:"service"}),". the ",(0,o.jsx)(s.strong,{children:"name"})," of this restaurant is Pizzeria. We make a ",(0,o.jsx)(s.strong,{children:"call"})," and request for a pizza. If the restaurant offers only one type of pizza, then we do not need to provide them any more information, but in most cases we need to let them know at least which ",(0,o.jsx)(s.strong,{children:"type"})," of pizza we would like. We may even want to further customize our order by choosing among different topping options (",(0,o.jsx)(s.strong,{children:"parameters"}),") they offer. Then all we need is to wait until the restaurant send us our pizza."]}),"\n",(0,o.jsxs)(s.p,{children:["ROS services works in similar fashion. A software program provides and advertise specific type of service along with required parameters. Others programs can call that service and get the response. For example, QTrobot provides a service called ",(0,o.jsx)(s.code,{children:"/qt_robot/speech/config"})," to configure the robot speaking language. The type of this service is ",(0,o.jsx)(s.code,{children:"qt_robot_interface/speech_config"})," and has some parameters such as ",(0,o.jsx)(s.code,{children:"language"})," and ",(0,o.jsx)(s.code,{children:"speed"}),". Another programs can call this service to change the robot's speaking language and talking speed at the run time."]}),"\n",(0,o.jsx)(s.h2,{id:"qtrobot-ros-topics-and-services",children:"QTrobot ROS Topics and Services"}),"\n",(0,o.jsx)(s.p,{children:"To get the list off all Topics or Services you can run one of this commands:"}),"\n",(0,o.jsx)(s.p,{children:"Topics:"}),"\n",(0,o.jsx)(s.pre,{children:(0,o.jsx)(s.code,{className:"language-bash",children:"rostopic list\n"})}),"\n",(0,o.jsx)(s.p,{children:"Services:"}),"\n",(0,o.jsx)(s.pre,{children:(0,o.jsx)(s.code,{className:"language-bash",children:"rosservice list\n"})}),"\n",(0,o.jsx)(s.h2,{id:"qtrobot-speech-interface",children:"QTrobot speech interface"}),"\n",(0,o.jsxs)(s.p,{children:["Let's start with QTrobot Speech interface. If you do ",(0,o.jsx)(s.code,{children:"rostopic list"})," you will see that one of the topics is ",(0,o.jsx)(s.code,{children:"/qt_robot/speech/say"}),". If we publish to that topic QTrobot will say the text message that we wrote. Open the terminal and try this:"]}),"\n",(0,o.jsx)(s.p,{children:"Publisher:"}),"\n",(0,o.jsx)(s.pre,{children:(0,o.jsx)(s.code,{className:"language-bash",children:"rostopic pub /qt_robot/speech/say std_msgs/String \"data: 'Hello I am QT'\"\n"})}),"\n",(0,o.jsx)(s.p,{children:"Service call:"}),"\n",(0,o.jsx)(s.pre,{children:(0,o.jsx)(s.code,{className:"language-bash",children:"rosservice call /qt_robot/speech/say \"message: 'Hello I am QT'\"\n"})}),"\n",(0,o.jsx)(s.h2,{id:"qtrobot-talk-text-interface",children:"QTrobot talk text interface"}),"\n",(0,o.jsxs)(s.p,{children:["The ",(0,o.jsx)(s.code,{children:"/qt_robot/behavior/talkText"})," interface is similar to ",(0,o.jsx)(s.code,{children:"/qt_robot/speech/say"})," interface with the only different that the talkText interface asks QTrobot to move his lips while reading the text messages. To try it, just add the following lines to our code and look at the QTrobot's face:"]}),"\n",(0,o.jsx)(s.p,{children:"Publisher:"}),"\n",(0,o.jsx)(s.pre,{children:(0,o.jsx)(s.code,{className:"language-bash",children:"rostopic pub /qt_robot/behavior/talkText std_msgs/String \"data: 'Hello I am QT'\"\n"})}),"\n",(0,o.jsx)(s.p,{children:"Service call:"}),"\n",(0,o.jsx)(s.pre,{children:(0,o.jsx)(s.code,{className:"language-bash",children:"rosservice call /qt_robot/behavior/talkText \"message: 'Hello I am QT'\"\n"})}),"\n",(0,o.jsx)(s.h2,{id:"qtrobot-emotion-interface",children:"QTrobot emotion interface"}),"\n",(0,o.jsxs)(s.p,{children:["Now lets show an emotion on QTrobot face. QTrobot comes with plenty of predefined emotion animations. You can find the complete list of the available emotions either using the ",(0,o.jsx)(s.em,{children:"QTrobot Educator app"})," or by looking into the ",(0,o.jsx)(s.code,{children:"~/robot/data/emotions"})," folder in ",(0,o.jsx)(s.strong,{children:"QTRP"}),"."]}),"\n",(0,o.jsx)(s.p,{children:"Publisher:"}),"\n",(0,o.jsx)(s.pre,{children:(0,o.jsx)(s.code,{className:"language-bash",children:"rostopic pub /qt_robot/emotion/show std_msgs/String \"data: 'QT/happy'\"\n"})}),"\n",(0,o.jsx)(s.p,{children:"Service call:"}),"\n",(0,o.jsx)(s.pre,{children:(0,o.jsx)(s.code,{className:"language-bash",children:"rosservice call /qt_robot/emotion/show \"name: 'QT/happy'\"\n"})}),"\n",(0,o.jsx)(s.admonition,{title:"Note",type:"note",children:(0,o.jsxs)(s.p,{children:["As it shown in the above example, you should ",(0,o.jsx)(s.strong,{children:"not"})," give the emotion's file extension (",(0,o.jsx)(s.code,{children:".avi"}),") to the interface!"]})}),"\n",(0,o.jsx)(s.h2,{id:"qtrobot-gesture-interface",children:"QTrobot gesture interface"}),"\n",(0,o.jsxs)(s.p,{children:["Now lets play a gesture with QTrobot. QTrobot comes with plenty of predefined gestures. You can find the complete list of the available gestures either using the ",(0,o.jsx)(s.em,{children:"QTrobot Educator app"})," or by looking into the ",(0,o.jsx)(s.code,{children:"~/robot/data/gestures"})," folder in ",(0,o.jsx)(s.strong,{children:"QTRP"}),"."]}),"\n",(0,o.jsx)(s.p,{children:"Publisher:"}),"\n",(0,o.jsx)(s.pre,{children:(0,o.jsx)(s.code,{className:"language-bash",children:"rostopic pub /qt_robot/gesture/play std_msgs/String \"data: 'QT/happy'\"\n"})}),"\n",(0,o.jsx)(s.p,{children:"Service call:"}),"\n",(0,o.jsx)(s.pre,{children:(0,o.jsx)(s.code,{className:"language-bash",children:"rosservice call /qt_robot/gesture/play \"name: 'QT/happy'\nspeed: 0.0\"\n"})}),"\n",(0,o.jsx)(s.p,{children:"rosservice call /qt_robot/gesture/play \"name: ''\nspeed: 0.0\""}),"\n",(0,o.jsx)(s.admonition,{title:"Note",type:"note",children:(0,o.jsxs)(s.p,{children:["As it shown in the above example, you should ",(0,o.jsx)(s.strong,{children:"not"})," give the gestures's file extension (",(0,o.jsx)(s.code,{children:".xml"}),") to the interface!"]})}),"\n",(0,o.jsx)(s.h2,{id:"qtrobot-audio-interface",children:"QTrobot audio interface"}),"\n",(0,o.jsxs)(s.p,{children:["Now lets play an audio file on QTrobot. QTrobot comes with some audio examples. You can find the complete list of the available audios either using the ",(0,o.jsx)(s.em,{children:"QTrobot Educator app"})," or by looking into the ",(0,o.jsx)(s.code,{children:"~/robot/data/audios"})," folder in ",(0,o.jsx)(s.strong,{children:"QTRP"}),".  QTrobot can play both audio ",(0,o.jsx)(s.em,{children:"wave"})," and ",(0,o.jsx)(s.em,{children:"mp3"})," files."]}),"\n",(0,o.jsx)(s.p,{children:"Publisher:"}),"\n",(0,o.jsx)(s.pre,{children:(0,o.jsx)(s.code,{className:"language-bash",children:"rostopic pub /qt_robot/audio/play std_msgs/String \"data: 'QT/Komiku_Glouglou'\"\n"})}),"\n",(0,o.jsx)(s.p,{children:"Service call:"}),"\n",(0,o.jsx)(s.pre,{children:(0,o.jsx)(s.code,{className:"language-bash",children:"rosservice call /qt_robot/audio/play \"filename: 'QT/Komiku_Glouglou'\nfilepath: ''\"\n"})}),"\n",(0,o.jsx)(s.admonition,{title:"Note",type:"note",children:(0,o.jsxs)(s.p,{children:["As it shown in the above example, you do not need to give the audio's file extension (",(0,o.jsx)(s.code,{children:".wav"})," or ",(0,o.jsx)(s.code,{children:".mp3"}),") to the interface!"]})})]})}function p(e={}){const{wrapper:s}={...(0,i.a)(),...e.components};return s?(0,o.jsx)(s,{...e,children:(0,o.jsx)(d,{...e})}):d(e)}}}]);